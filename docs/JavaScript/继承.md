<!--
 * @Author: liushuhao
 * @Date: 2021-03-04 21:29:03
 * @LastEditors: liushuhao
 * @LastEditTime: 2021-03-05 16:54:13
-->
# 继承
## es5 继承
```js
function Foo(name) { 
    this.name = name;
}

Foo.prototype.myName = function() { 
    returnthis.name
}

function Bar(name,label) {
     // 1. 继承 Foo 的属性
    Foo.call( this, name )  
    this.label = label
}

// 2. 继承 Foo 原型链的方法
Bar.prototype = Object.create( Foo.prototype )  

// 3. 修改子类的 constructor
Bar.prototype.constructor = Bar
```


```
下面这两种方式是常见的错误做法
```js
Bar.prototype = Foo.prototype
```
Bar.prototype 直接引用了 Foo.prototype 对象。所以修改时会互相影响

```js
Bar.prototype = new Foo()
```
Bar.prototype =  new Foo() 的确会创建一个关联到Bar.prototype的新对象。但是如果函数 Foo 有一些副作用（ 比如写日志、 修改状态、 注册到其他对象、 给this添加数据属性， 等等）的话， 就会影响到Bar()的“ 后代”，后果不堪设想。

Object.create( Foo.prototype ) 和 new Foo() 的区别
```js
Object.create = (obj) => {
    function F() {}
    F.prototype = obj
    return new F()
}
```

## ES6 继承
```js
class Point {
}

class ColorPoint extends Point {
    constructor(x, y, color) {
        super(x, y); // 调用父类的constructor(x, y)
        this.color = color;
    }

    toString() {
        return this.color + ' ' + super.toString(); // 调用父类的toString()
    }
}
```